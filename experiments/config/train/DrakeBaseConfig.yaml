seed: 0
log_freq: 10
save_model_freq: 1000
input_type: 'image'
replaybuffer_size: 400 # just need to be the max length of a trajectory for saving demonstrations
train_frequency: 1 # how many environment iterations for a training iteration
feature_extractor: resnet18 # which feature extractor
train_repr: False 
local_train_iter_multiplier: 0
frame_per_episode: 2
batch_episode_fraction: 0.8
keypoint_loss: False # use keypoint to measure the loss
add_augment_uniform_noise: False # add small uniform noises during training
add_augment_corrective_noise: True # add structured pose noises and corrective action during training
add_augment_premultiply_pose: False # apply random transform to the two pointclouds
add_augment_dagger_noise: True # set state using the next action and add corrective action during training

hand_pt_bc_loss:  False # use the sparse point loss on hand
dense_pt_bc_loss:  True # use the dense tool point loss  

joint_add_noise: False # add noises during training
keypoint_processing: False # processing keypoints
keypoint_normalization: False # normalizing keypoints by subtracting the object coord
keypoint_mask: False # add mask to denote if the points belong to object or the tool
numObservations: [6, 240, 320] # 6 for RGB and 10 for RGBDM
additional_robot_state: True
additional_end_effector_pose: False # use pose instead of joint angle for the robot state
additional_endeffector_wrench: False # add additional end effector wrench
normalize_color_image: False
time_contrastive_loss: False
time_contrastive_loss2: False
img_type: 'RGB'
time_contrastive_loss_scale: 1.
two_view_feature_fusion: 'add' # how to fuse the features from both views
train_test_shape_split: 0.8 # how to fuse the features from both views
pointcloud: False # use pointcloud policy
transformer: False
per_object_pointnet: False
point_feat_dim: 4
goal_auxiliary_loss: False  # add predicting goal as an auxiliary loss
vis_predictions: True  # visualize the policy network predictions
append_timestep: False  # append timestep to the features
pointcloud_add_noise: False # add pose delta to state and inverse pose delta to actions 
goal_auxiliary_scale: 1.0
clip_grad: False
clip_grad_norm: 0.1
use_axis_angle: False
latent_attn_policy: False
state_attn_policy: False
training_point_num: 1024
filter_zero_action: False
dense_obj_pt_loss: False
point_cross_attn_encoder: False
keypoint_as_special_pc: False
pc_transformer_spatial_token_num: 0
local_agent: False # whether to have local agents

warmup_step: 2000
warmup_lr: 0.00001
use_warmup_lr: True
ignore_state: False
optim: 'Adam'

policy:
  state_hidden_dim: 256
  num_state_dim: 12
  num_force_dim: 6 # 32 x 6
  separate_shared_encoder: True  
  latent_size: 512 # 512 + 512
  num_keypoint_dim: 12
  extra_pred_dim: 0
  policy_hidden_dim: 512
  transformer_layer_num: 3
  transformer_heads: 1  
  transformer_state_feat_num: 5
repr:
  task: don

learn:
  agent_name: franka
  test: False
  optim_stepsize: 0.0003 # learning rate
  encoder_optim_stepsize: 0.0003 # learning rate
  fixed_encoder: False # learning rate

  minibatches: 16 # batch size
  policy_milestones: [10000, 30000, 70000] # to decrease lr
  lr_gamma: 0.5 # how much to decay at each iterations 
  loss_scale: 1. # the scale of applied loss
